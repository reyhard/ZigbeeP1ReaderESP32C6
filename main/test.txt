/*
 * SPDX-FileCopyrightText: 2021-2022 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 *
 * Zigbee HA_color_dimmable_light Example
 *
 * This example code is in the Public Domain (or CC0 licensed, at your option.)
 *
 * Unless required by applicable law or agreed to in writing, this
 * software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 */
#include "zboss_api.h"
#include "esp_zb_p1reader.h"
#include "esp_check.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "ha/esp_zigbee_ha_standard.h"
#include "settings.h"

#include "driver/gpio.h"
#include "driver/uart.h"

#include <stdint.h>
#include <stdlib.h>  // For rand
#include <time.h>    // For time

#include "utils.h"


#define GPIO_OUTPUT_IO_0    11
#define GPIO_OUTPUT_IO_1    7
// | (1ULL<<GPIO_OUTPUT_IO_1)
#define GPIO_OUTPUT_PIN_SEL  ((1ULL<<GPIO_OUTPUT_IO_0) )
#define CO2_CUSTOM_CLUSTER              0xFFF2

#define UART_NUM UART_NUM_1
#define UART_TX_PIN  (GPIO_NUM_16)
#define UART_RX_PIN  (GPIO_NUM_17)
#define BUF_SIZE (1024)

#if !defined CONFIG_ZB_ZCZR
#error Define ZB_ZCZR in idf.py menuconfig to compile light (Router) source code.
#endif

static const char *TAG = "ESP_ZB_P1READER";

bool lightFlow = 0;
uint8_t autoOffDuration = 1;
uint16_t energyLowValue = 0;


static int16_t zb_temperature_to_s16(float temp)
{
    return (int16_t)(temp * 100);
}
double lerp(double start, double end, double t) {
    // Clamp t to the range [0, 1]
    t = fmax(0.0, fmin(1.0, t));

    // Linear interpolation formula
    return (1 - t) * start + t * end;
}


// Function to generate a random uint8_t in the range [0, 2]
uint8_t getRandomUint8() {
    return (uint8_t)(rand() % 3);
}
#define BLINK_GPIO 15
/********************* Define functions **************************/
static void configure_led(void)
{
    ESP_LOGI(TAG, "Example configured to blink GPIO LED!");
    gpio_reset_pin(BLINK_GPIO);
    /* Set the GPIO as a push/pull output */
    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
}

void reportAttribute(uint8_t endpoint, uint16_t clusterID, uint16_t attributeID, void *value, uint8_t value_length)
{
    esp_zb_zcl_report_attr_cmd_t cmd = {
        .zcl_basic_cmd = {
            .dst_addr_u.addr_short = 0x0000,
            .dst_endpoint = endpoint,
            .src_endpoint = endpoint,
        },
        .address_mode = ESP_ZB_APS_ADDR_MODE_16_ENDP_PRESENT,
        .clusterID = clusterID,
        .attributeID = attributeID,
        .cluster_role = ESP_ZB_ZCL_CLUSTER_SERVER_ROLE,
    };
    esp_zb_zcl_attr_t *value_r = esp_zb_zcl_get_attribute(endpoint, clusterID, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE, attributeID);
    ESP_LOGI(TAG, "Mem %s", value_r);
    memcpy(value_r->data_p, value, value_length);
    ESP_LOGI(TAG, "Write");
    esp_zb_zcl_report_attr_cmd_req(&cmd);
}

static void esp_delayed_off(void *pvParameters)
{
    vTaskDelay((1000 *  1) / portTICK_PERIOD_MS);
    ESP_LOGI(TAG, "Auto off started %d",autoOffDuration);
    vTaskDelay((1000 *  autoOffDuration) / portTICK_PERIOD_MS);
    
    gpio_set_level(GPIO_OUTPUT_IO_0, 0);
    //light_driver_set_power(0);
    gpio_set_level(BLINK_GPIO, 0);
    ESP_LOGI(TAG, "Auto off end");
    bool val = 0;
    reportAttribute(HA_DEVICE_ENDPOINT, ESP_ZB_ZCL_CLUSTER_ID_ON_OFF, ESP_ZB_ZCL_ATTR_ON_OFF_ON_OFF_ID, &val, 2);


    energyLowValue = rand() % (3000 + 1 - 400);
    /* Write new CO2_value value */
    uint16_t measured_value = zb_temperature_to_s16(energyLowValue);
    esp_zb_lock_acquire(portMAX_DELAY);
    esp_zb_zcl_status_t state_co2 = esp_zb_zcl_set_attribute_val(HA_DEVICE_ENDPOINT, ENERGY_LOW_CUSTOM_CLUSTER, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE, ESP_ZB_ZCL_ATTR_TEMP_MEASUREMENT_VALUE_ID, &measured_value, false);
    esp_zb_lock_release();

    ESP_LOGI(TAG, "Attribute prepared %d",energyLowValue);
    /* Check for error */
    if(state_co2 != ESP_ZB_ZCL_STATUS_SUCCESS)
    {
        ESP_LOGE(TAG, "Setting CO2_value attribute failed! %d",state_co2);
    }else{
        /* CO2 Cluster is custom and we must report it manually*/
        reportAttribute(HA_DEVICE_ENDPOINT, ENERGY_LOW_CUSTOM_CLUSTER, 0, &energyLowValue, 2);
    }
        reportAttribute(HA_DEVICE_ENDPOINT, ENERGY_LOW_CUSTOM_CLUSTER, 0, &energyLowValue, 1);


    vTaskDelete(NULL);
}

/********************* Define functions **************************/
static void bdb_start_top_level_commissioning_cb(uint8_t mode_mask)
{
    ESP_ERROR_CHECK(esp_zb_bdb_start_top_level_commissioning(mode_mask));
}

void esp_zb_app_signal_handler(esp_zb_app_signal_t *signal_struct)
{
    uint32_t *p_sg_p = signal_struct->p_app_signal;
    esp_err_t err_status = signal_struct->esp_err_status;
    esp_zb_app_signal_type_t sig_type = *p_sg_p;
    switch (sig_type) {
    case ESP_ZB_ZDO_SIGNAL_SKIP_STARTUP:
        ESP_LOGI(TAG, "Zigbee stack initialized");
        esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_INITIALIZATION);
        break;
    case ESP_ZB_BDB_SIGNAL_DEVICE_FIRST_START:
    case ESP_ZB_BDB_SIGNAL_DEVICE_REBOOT:
        if (err_status == ESP_OK) {
            ESP_LOGI(TAG, "Start network steering");
            esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_NETWORK_STEERING);
        } else {
            ESP_LOGW(TAG, "Failed to initialize Zigbee stack (status: %s)", esp_err_to_name(err_status));
        }
        break;
    case ESP_ZB_BDB_SIGNAL_STEERING:
        if (err_status == ESP_OK) {
            esp_zb_ieee_addr_t extended_pan_id;
            esp_zb_get_extended_pan_id(extended_pan_id);
            ESP_LOGI(TAG, "Joined network successfully (Extended PAN ID: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, PAN ID: 0x%04hx, Channel:%d, Short Address: 0x%04hx)",
                     extended_pan_id[7], extended_pan_id[6], extended_pan_id[5], extended_pan_id[4],
                     extended_pan_id[3], extended_pan_id[2], extended_pan_id[1], extended_pan_id[0],
                     esp_zb_get_pan_id(), esp_zb_get_current_channel(), esp_zb_get_short_address());
        } else {
            ESP_LOGI(TAG, "Network steering was not successful (status: %s)", esp_err_to_name(err_status));
            esp_zb_scheduler_alarm((esp_zb_callback_t)bdb_start_top_level_commissioning_cb, ESP_ZB_BDB_MODE_NETWORK_STEERING, 1000);
        }
        break;
    case ESP_ZB_NWK_SIGNAL_PERMIT_JOIN_STATUS:
        if (err_status == ESP_OK) {
            if (*(uint8_t *)esp_zb_app_signal_get_params(p_sg_p)) {
                ESP_LOGI(TAG, "Network(0x%04hx) is open for %d seconds", esp_zb_get_pan_id(), *(uint8_t *)esp_zb_app_signal_get_params(p_sg_p));
            } else {
                ESP_LOGW(TAG, "Network(0x%04hx) closed, devices joining not allowed.", esp_zb_get_pan_id());
            }
        }
        break;
    default:
        ESP_LOGI(TAG, "ZDO signal: %s (0x%x), status: %s", esp_zb_zdo_signal_to_string(sig_type), sig_type, esp_err_to_name(err_status));
        break;
    }
}

static esp_err_t zb_attribute_handler(const esp_zb_zcl_set_attr_value_message_t *message)
{
    esp_err_t ret = ESP_OK;
    bool light_state = 0;
    ESP_RETURN_ON_FALSE(message, ESP_FAIL, TAG, "Empty message");
    ESP_RETURN_ON_FALSE(message->info.status == ESP_ZB_ZCL_STATUS_SUCCESS, ESP_ERR_INVALID_ARG, TAG, "Received message: error status(%d)",
                        message->info.status);
    ESP_LOGI(TAG, "Received message: endpoint(%d), cluster(0x%x), attribute(0x%x), data size(%d)", message->info.dst_endpoint, message->info.cluster,
             message->attribute.id, message->attribute.data.size);
    if (message->info.dst_endpoint == HA_DEVICE_ENDPOINT) {
        switch (message->info.cluster) {
        case ESP_ZB_ZCL_CLUSTER_ID_ON_OFF:
            if (message->attribute.id == ESP_ZB_ZCL_ATTR_ON_OFF_ON_OFF_ID && message->attribute.data.type == ESP_ZB_ZCL_ATTR_TYPE_BOOL) {
                light_state = message->attribute.data.value ? *(bool *)message->attribute.data.value : light_state;
                ESP_LOGI(TAG, "Light sets to %s", light_state ? "On" : "Off");
                
                gpio_set_level(GPIO_OUTPUT_IO_0, light_state ? 1 : 0);
                //light_driver_set_power(light_state);
                gpio_set_level(BLINK_GPIO, light_state);
                if(light_state) {
                    xTaskCreate(esp_delayed_off, "Delayed_Off", 4096, NULL, 3, NULL);
                }
            } else {
                ESP_LOGW(TAG, "On/Off cluster data: attribute(0x%x), type(0x%x)", message->attribute.id, message->attribute.data.type);
            }
            break;
        case ESP_ZB_ZCL_CLUSTER_ID_LEVEL_CONTROL:
            if (message->attribute.id == ESP_ZB_ZCL_ATTR_LEVEL_CONTROL_CURRENT_LEVEL_ID && message->attribute.data.type == ESP_ZB_ZCL_ATTR_TYPE_U8) {
                autoOffDuration = message->attribute.data.value ? *(uint8_t *)message->attribute.data.value : autoOffDuration;
                //light_driver_set_level((uint8_t)light_level);
                ESP_LOGI(TAG, "Light level changes to %d", autoOffDuration);
            } else {
                ESP_LOGW(TAG, "Level Control cluster data: attribute(0x%x), type(0x%x)", message->attribute.id, message->attribute.data.type);
            }
            break;
        default:
            ESP_LOGI(TAG, "Message data: cluster(0x%x), attribute(0x%x)  ", message->info.cluster, message->attribute.id);
        }
    }
    
    return ret;
}

static esp_err_t zb_action_handler(esp_zb_core_action_callback_id_t callback_id, const void *message)
{
    esp_err_t ret = ESP_OK;
    switch (callback_id) {
    case ESP_ZB_CORE_CMD_CUSTOM_CLUSTER_REQ_CB_ID:
        ESP_LOGI(TAG, "Custom Message data");
        break;
    case ESP_ZB_CORE_SET_ATTR_VALUE_CB_ID:
        ret = zb_attribute_handler((esp_zb_zcl_set_attr_value_message_t *)message);
        break;
    default:
        ESP_LOGW(TAG, "Receive Zigbee action(0x%x) callback", callback_id);
        break;
    }
    return ret;
}
char modelid[] = {18, 'E', 'S', 'P', '3', '2', 'C', '6', '.', 'P', '1', '.', 'R', 'e', 'a', 'd', 'e', 'r'};
char manufname[] = {9, 'E', 's', 'p', 'r', 'e', 's', 's', 'i', 'f'};

void printBinaryData(const uint8_t* data, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        printf("%02x ", data[i]);
    }
    printf("\n");
}

bool esp_zb_raw_command_handler(uint8_t bufid)
{
    zb_zcl_report_attr_req_t *req = NULL;
    zb_zcl_parsed_hdr_t *cmd_info = ZB_BUF_GET_PARAM(bufid, zb_zcl_parsed_hdr_t);

    uint8_t data[zb_buf_len(bufid)];
    memcpy(data, zb_buf_begin(bufid), sizeof(data));
    ESP_LOGW(TAG, "Got data2, size: %d", sizeof(data));

    printf("start dst_ep: %d, cluster id: 0x%x, cmd id: 0x%x\n", cmd_info->addr_data.common_data.dst_endpoint, cmd_info->cluster_id, cmd_info->cmd_id );
    //  && cmd_info->is_common_command && cmd_info->cmd_id == 0x2
    if(cmd_info)
    {
        bool handle_read_attr_request = false;
        uint8_t dst_ep = cmd_info->addr_data.common_data.dst_endpoint;

        /*ZB_ZCL_GENERAL_GET_NEXT_REPORT_ATTR_REQ(bufid, req);
        if(req){    
            printf("atr: %d\n", req->attr_id );

        }    

        if (!cmd_info->disable_default_response)
        {
            //zb_zcl_send_default_handler(bufid, cmd_info, ZB_ZCL_STATUS_SUCCESS);
            zb_buf_free(bufid);
        }
        else
        {
            zb_buf_free(bufid);
        }
        return true;*/
        // Iterate on the number of requested attributes
        int req_len= sizeof(uint16_t);
        printBinaryData(data, sizeof(data));
        for (int i = 0; i < sizeof(data); i += req_len)
        {
            uint16_t attr_id = (data[i] << 8) | data[i+1];
            ESP_LOGI(TAG, "Read attr: 0x%04x", attr_id);

            // If request includes custom attribute, mark handle request
            if (attr_id == 0xf2ff)
            {
                //uint16_t attr_data = (data[i+req_len] << sizeof(bool)) | data[i+req_len+1];;
                bool boolValue;
                memcpy(&boolValue, data + sizeof(uint16_t)+sizeof(bool), sizeof(bool));
                //| data[i+sizeof(bool)+1];
                ESP_LOGI(TAG, "data: %s", boolValue ? "true" : "false");
                
                lightFlow = !boolValue;
                if(!boolValue)
                {
                    xTaskCreate(esp_delayed_off, "Delayed_Off", 4096, NULL, 3, NULL);
                }

                handle_read_attr_request = true;
                zb_zcl_send_default_handler(bufid, cmd_info, ZB_ZCL_STATUS_SUCCESS);
                return false;
            }
/*
            esp_zb_zcl_attr_t* pAttr = esp_zb_zcl_get_attribute(dst_ep, 
                                                                cmd_info->cluster_id,
                                                                ZB_ZCL_CLUSTER_SERVER_ROLE,
                                                                attr_id);
            ESP_LOGI(TAG, "pAttr: %p", pAttr);
            if (pAttr != NULL)
            {
                ESP_LOGI(TAG, "pAttr->Id  : %d", pAttr->id);
                ESP_LOGI(TAG, "pAttr->Data: %p", pAttr->data_p);
                // Add data to response request...
                printf("data");
            }*/
        }
        //zb_zcl_send_default_handler(bufid, cmd_info, ZB_ZCL_STATUS_SUCCESS);
        return false;
    }
    
    return false;
}

static esp_zb_cluster_list_t *basic_identity_clusters_create() {
   esp_zb_cluster_list_t *cluster_list = esp_zb_zcl_cluster_list_create();
    esp_zb_basic_cluster_cfg_t basic_config = {
        .power_source = ESP_ZB_ZCL_BASIC_POWER_SOURCE_DEFAULT_VALUE,
        .zcl_version = ESP_ZB_ZCL_BASIC_ZCL_VERSION_DEFAULT_VALUE
    };

    esp_zb_attribute_list_t *basic_cluster = esp_zb_basic_cluster_create(&basic_config);
    ESP_ERROR_CHECK(esp_zb_basic_cluster_add_attr(basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MANUFACTURER_NAME_ID, MANUFACTURER_NAME));
    ESP_ERROR_CHECK(esp_zb_basic_cluster_add_attr(basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MODEL_IDENTIFIER_ID, MODEL_IDENTIFIER));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_basic_cluster(cluster_list, basic_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    esp_zb_identify_cluster_cfg_t identify_config = {
        .identify_time = 100
    };
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_identify_cluster(cluster_list, esp_zb_identify_cluster_create(&identify_config), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_identify_cluster(cluster_list, esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_IDENTIFY), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE));
    return cluster_list;
}

static esp_zb_cluster_list_t *custom_temperature_sensor_clusters_create(esp_zb_temperature_sensor_cfg_t *temperature_sensor)
{
    esp_zb_cluster_list_t *cluster_list = esp_zb_zcl_cluster_list_create();
    esp_zb_attribute_list_t *basic_cluster = esp_zb_basic_cluster_create(&(temperature_sensor->basic_cfg));
    ESP_ERROR_CHECK(esp_zb_basic_cluster_add_attr(basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MANUFACTURER_NAME_ID, MANUFACTURER_NAME));
    ESP_ERROR_CHECK(esp_zb_basic_cluster_add_attr(basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MODEL_IDENTIFIER_ID, MODEL_IDENTIFIER));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_basic_cluster(cluster_list, basic_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_identify_cluster(cluster_list, esp_zb_identify_cluster_create(&(temperature_sensor->identify_cfg)), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_identify_cluster(cluster_list, esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_IDENTIFY), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE));
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_temperature_meas_cluster(cluster_list, esp_zb_temperature_meas_cluster_create(&(temperature_sensor->temp_meas_cfg)), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    return cluster_list;
}

static esp_zb_ep_list_t *custom_temperature_sensor_ep_create(uint8_t endpoint_id, esp_zb_temperature_sensor_cfg_t *temperature_sensor)
{
    esp_zb_ep_list_t *ep_list = esp_zb_ep_list_create();
    esp_zb_endpoint_config_t endpoint_config = {
        .endpoint = endpoint_id,
        .app_profile_id = ESP_ZB_AF_HA_PROFILE_ID,
        .app_device_id = ESP_ZB_HA_TEMPERATURE_SENSOR_DEVICE_ID,
        .app_device_version = 0
    };
    esp_zb_ep_list_add_ep(ep_list, custom_temperature_sensor_clusters_create(temperature_sensor), endpoint_config);
    return ep_list;
}


static void esp_zb_task(void *pvParameters)
{

    /* initialize Zigbee stack with Zigbee end-device config */
    esp_zb_cfg_t zb_nwk_cfg = ESP_ZB_ZR_CONFIG();
    esp_zb_init(&zb_nwk_cfg);

    /* set the on-off light device config */
    uint8_t test_attr, test_attr2;
    uint16_t undefined_value;
    undefined_value = 0x8000;

    test_attr = 0;
    test_attr2 = 4;
    /* basic cluster create with fully customized */
    
    esp_zb_attribute_list_t *esp_zb_basic_cluster = esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_BASIC);
    esp_zb_basic_cluster_add_attr(esp_zb_basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_ZCL_VERSION_ID, &test_attr);
    esp_zb_basic_cluster_add_attr(esp_zb_basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_POWER_SOURCE_ID, &test_attr2);
    esp_zb_cluster_update_attr(esp_zb_basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_ZCL_VERSION_ID, &test_attr2);
    esp_zb_basic_cluster_add_attr(esp_zb_basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MODEL_IDENTIFIER_ID, MODEL_IDENTIFIER);
    esp_zb_basic_cluster_add_attr(esp_zb_basic_cluster, ESP_ZB_ZCL_ATTR_BASIC_MANUFACTURER_NAME_ID, MANUFACTURER_NAME);
    /* identify cluster create with fully customized */
    esp_zb_attribute_list_t *esp_zb_identify_cluster = esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_IDENTIFY);
    esp_zb_identify_cluster_add_attr(esp_zb_identify_cluster, ESP_ZB_ZCL_ATTR_IDENTIFY_IDENTIFY_TIME_ID, &test_attr);
    /* group cluster create with fully customized */
    esp_zb_attribute_list_t *esp_zb_groups_cluster = esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_GROUPS);
    esp_zb_groups_cluster_add_attr(esp_zb_groups_cluster, ESP_ZB_ZCL_ATTR_GROUPS_NAME_SUPPORT_ID, &test_attr);
    /* scenes cluster create with standard cluster + customized */
    esp_zb_attribute_list_t *esp_zb_scenes_cluster = esp_zb_scenes_cluster_create(NULL);
    esp_zb_cluster_update_attr(esp_zb_scenes_cluster, ESP_ZB_ZCL_ATTR_SCENES_NAME_SUPPORT_ID, &test_attr);
    /* on-off cluster create with standard cluster config*/
    esp_zb_on_off_cluster_cfg_t on_off_cfg;
    on_off_cfg.on_off = ESP_ZB_ZCL_ON_OFF_ON_OFF_DEFAULT_VALUE;
    esp_zb_attribute_list_t *esp_zb_on_off_cluster = esp_zb_on_off_cluster_create(&on_off_cfg);

    esp_zb_level_cluster_cfg_t level_cfg;
    level_cfg.current_level = 3;
    esp_zb_attribute_list_t *esp_zb_level_cluster = esp_zb_level_cluster_create(&level_cfg);

    /* create cluster lists for this endpoint */
    esp_zb_cluster_list_t *esp_zb_cluster_list = esp_zb_zcl_cluster_list_create();
    esp_zb_cluster_list_add_basic_cluster(esp_zb_cluster_list, esp_zb_basic_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);

    // custom energy attributes
    uint8_t ApplicationVersion = 1;
    const uint16_t attr_id = 0;
    const uint8_t attr_type = ESP_ZB_ZCL_ATTR_TYPE_U16;
    const uint8_t attr_access = ESP_ZB_ZCL_ATTR_MANUF_SPEC | ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY | ESP_ZB_ZCL_ATTR_ACCESS_REPORTING;

    esp_zb_attribute_list_t *custom_energy_low_attributes_list = esp_zb_zcl_attr_list_create(ENERGY_LOW_CUSTOM_CLUSTER);
    esp_zb_cluster_add_attr(custom_energy_low_attributes_list, ENERGY_LOW_CUSTOM_CLUSTER, 0x0001, ESP_ZB_ZCL_ATTR_TYPE_U8, ESP_ZB_ZCL_ATTR_ACCESS_REPORTING, &ApplicationVersion);
    esp_zb_custom_cluster_add_custom_attr(custom_energy_low_attributes_list, 0x0001, ESP_ZB_ZCL_ATTR_TYPE_U8, ESP_ZB_ZCL_ATTR_ACCESS_REPORTING, &ApplicationVersion);

    esp_zb_cluster_list_add_custom_cluster(esp_zb_cluster_list, custom_energy_low_attributes_list, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);

    /*esp_zb_attribute_list_t *custom_energy_low_attributes_list = esp_zb_zcl_attr_list_create(ENERGY_LOW_CUSTOM_CLUSTER);
    esp_zb_custom_cluster_add_custom_attr(custom_energy_low_attributes_list, attr_id, attr_type, attr_access, &energyLowValue);  
    esp_zb_cluster_list_add_custom_cluster(esp_zb_cluster_list, custom_energy_low_attributes_list, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);*/

    /* Create customized temperature sensor endpoint */
    /* update basic cluster in the existed cluster list */
    //esp_zb_cluster_list_update_basic_cluster(esp_zb_cluster_list, esp_zb_basic_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);
    esp_zb_cluster_list_add_identify_cluster(esp_zb_cluster_list, esp_zb_identify_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);
    esp_zb_cluster_list_add_groups_cluster(esp_zb_cluster_list, esp_zb_groups_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);
    esp_zb_cluster_list_add_scenes_cluster(esp_zb_cluster_list, esp_zb_scenes_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);
    esp_zb_cluster_list_add_on_off_cluster(esp_zb_cluster_list, esp_zb_on_off_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE); 
    esp_zb_cluster_list_add_level_cluster(esp_zb_cluster_list, esp_zb_level_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);

    
    esp_zb_temperature_meas_cluster_cfg_t sensor_cfg;
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_temperature_meas_cluster(esp_zb_cluster_list, esp_zb_temperature_meas_cluster_create(&(sensor_cfg)), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    esp_zb_metering_cluster_cfg_t metering_cfg;
    ESP_ERROR_CHECK(esp_zb_cluster_list_add_metering_cluster(esp_zb_cluster_list, esp_zb_metering_cluster_create(&(metering_cfg)), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));
    //esp_zb_metering_cluster_cfg_t metering_cfg;
    //ESP_ERROR_CHECK(esp_zb_cluster_list_add_metering_cluster(esp_zb_cluster_list, esp_zb_metering_cluster_create(&(metering_cfg)), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE));

    esp_zb_ep_list_t *esp_zb_ep_list = esp_zb_ep_list_create();

    /* add created endpoint (cluster_list) to endpoint list */
    esp_zb_endpoint_config_t endpoint_config = {
        .endpoint = HA_DEVICE_ENDPOINT,
        .app_profile_id = ESP_ZB_AF_HA_PROFILE_ID,
        .app_device_id = ESP_ZB_HA_TEST_DEVICE_ID,
        .app_device_version = 0
    };
    esp_zb_ep_list_add_ep(esp_zb_ep_list, esp_zb_cluster_list, endpoint_config);

    esp_zb_device_register(esp_zb_ep_list);
    esp_zb_core_action_handler_register(zb_action_handler);
    esp_zb_raw_command_handler_register(esp_zb_raw_command_handler);

    /* Config the reporting info  */
    esp_zb_zcl_reporting_info_t reporting_info = {
        .direction = ESP_ZB_ZCL_CMD_DIRECTION_TO_SRV,
        .ep = HA_DEVICE_ENDPOINT,
        .cluster_id = ENERGY_LOW_CUSTOM_CLUSTER,
        .cluster_role = ESP_ZB_ZCL_CLUSTER_SERVER_ROLE,
        .dst.profile_id = ESP_ZB_AF_HA_PROFILE_ID,
        .u.send_info.min_interval = 1,
        .u.send_info.max_interval = 0,
        .u.send_info.def_min_interval = 1,
        .u.send_info.def_max_interval = 0,
        .u.send_info.delta.u16 = 100,
        .attr_id = ESP_ZB_ZCL_ATTR_TEMP_MEASUREMENT_VALUE_ID,
        .manuf_code = ESP_ZB_ZCL_ATTR_NON_MANUFACTURER_SPECIFIC,
    };

    esp_zb_zcl_update_reporting_info(&reporting_info);

    esp_zb_set_primary_network_channel_set(ESP_ZB_PRIMARY_CHANNEL_MASK);
    ESP_ERROR_CHECK(esp_zb_start(false));
    
    esp_zb_main_loop_iteration();
}



// Send single value
/*void sendMetric(String name, long metric, uint16_t attribute)
{
    ts_DstAddr sDstAddr;

    sDstAddr.u16DstAddr = 0x0000;
    zbhci_ZclSendReportCmd(0x02, sDstAddr, 1, 1, 0, 1, 0x702, attribute, ZCL_DATA_TYPE_DATA32, sizeof(metric), (uint8_t *)&metric);
    delay(100);
}

// Send 3 values at once
void sendMetric3(String name, uint56_t metric, uint16_t attribute)
{
    ts_DstAddr sDstAddr;

    sDstAddr.u16DstAddr = 0x0000;
    zbhci_ZclSendReportCmd(0x02, sDstAddr, 1, 1, 0, 1, 0x702, attribute, ZCL_DATA_TYPE_DATA56, sizeof(metric), (uint8_t *)&metric);
    delay(100);
}*/

/*void sendDataToBroker()
{
    for (int i = 0; i < NUMBER_OF_READOUTS; i++)
    {
        if (telegramObjects[i].sendData)
        {
#ifdef DEBUG
        Serial.println((String) "Sending: " + telegramObjects[i].name + " value: " + telegramObjects[i].value);
#endif
            if(telegramObjects[i].attributeID == 0x4004) {
                uint56_t report;
                telegramObjects[7].sendData = false;
                telegramObjects[8].sendData = false;
                telegramObjects[9].sendData = false;
                report.high = telegramObjects[7].value;
                report.mid = telegramObjects[8].value;
                report.low = telegramObjects[9].value;
                sendMetric3(telegramObjects[i].name, report, telegramObjects[i].attributeID);

            }else{
                sendMetric(telegramObjects[i].name, telegramObjects[i].value, telegramObjects[i].attributeID);
                telegramObjects[i].sendData = false;
            }
        }
    }
}*/

/***********************************
            Setup Methods
 ***********************************/

/**
   setupDataReadout()

   This method can be used to create more data readout to mqtt topic.
   Use the name for the mqtt topic.
   The code for finding this in the telegram see
    https://www.netbeheernederland.nl/_upload/Files/Slimme_meter_15_a727fce1f1.pdf for the dutch codes pag. 19 -23
   Use startChar and endChar for setting the boundies where the value is in between.
   Default startChar and endChar is '(' and ')'
   Note: Make sure when you add or remove telegramObject to update the NUMBER_OF_READOUTS accordingly.
*/

void setupDataReadout()
{
    
    // 0-0:96.14.0(0001)
    // 0-0:96.14.0 = Actual Tarif
    strcpy(telegramObjects[0].name, "energy_tariff");
    telegramObjects[0].attributeID = (uint16_t) 16386;
    strcpy(telegramObjects[0].code, "0-0:96.14.0");
    telegramObjects[0].startChar = '(';
    telegramObjects[0].endChar = ')';
    telegramObjects[0].sendData = false;

    // 1-0:1.8.1(000992.992*kWh)
    // 1-0:1.8.1 = Elektra verbruik laag tarief (DSMR v5.0)
    strcpy(telegramObjects[1].name, "energy_low");
    telegramObjects[1].attributeID = (uint16_t) 16384;
    strcpy(telegramObjects[1].code, "1-0:1.8.1");
    telegramObjects[1].startChar = '(';
    telegramObjects[1].endChar = '*';
    telegramObjects[1].sendData = false;

    // 1-0:1.8.2(000560.157*kWh)
    // 1-0:1.8.2 = Elektra verbruik hoog tarief (DSMR v5.0)
    strcpy(telegramObjects[2].name, "energy_high");
    telegramObjects[2].attributeID = (uint16_t) 16385;
    strcpy(telegramObjects[2].code, "1-0:1.8.2");
    telegramObjects[2].startChar = '(';
    telegramObjects[2].endChar = '*';
    telegramObjects[2].sendData = false;

    // 1-0:1.7.0(00.424*kW) Actueel verbruik
    // 1-0:1.7.x = Electricity consumption actual usage (DSMR v5.0)
    strcpy(telegramObjects[3].name, "power");
    telegramObjects[3].attributeID = (uint16_t) 16387;
    strcpy(telegramObjects[3].code, "1-0:1.7.0");
    telegramObjects[3].startChar = '(';
    telegramObjects[3].endChar = '*';
    telegramObjects[3].sendData = false;
    telegramObjects[3].sendThreshold = (long) 3;

    // 0-1:24.2.3(150531200000S)(00811.923*m3)
    // 0-1:24.2.3 = Gas (DSMR v5.0) on Belgian meters
    strcpy(telegramObjects[4].name, "gas");
    telegramObjects[4].attributeID = (uint16_t) 16389;
    strcpy(telegramObjects[4].code, "0-1:24.2.1");
    telegramObjects[4].startChar = '(';
    telegramObjects[4].endChar = '*';
    telegramObjects[4].sendData = false;
    
    // 0-0:96.7.21(00008)
    // Number of power failures in any phases
    strcpy(telegramObjects[5].name, "fail");
    telegramObjects[5].attributeID = (uint16_t) 16390;
    strcpy(telegramObjects[5].code, "0-0:96.7.21");
    telegramObjects[5].startChar = '(';
    telegramObjects[5].endChar = ')';
    telegramObjects[5].sendData = false;

    // 0-0:96.7.9(00002)
    // Number of long power failures in any phases
    //telegramObjects[6].name = "fail_long";
    strcpy(telegramObjects[6].name, "fail_long");
    telegramObjects[6].attributeID = (uint16_t) 16391;
    strcpy(telegramObjects[6].code, "0-0:96.7.9");
    telegramObjects[6].startChar = '(';
    telegramObjects[6].endChar = ')';
    telegramObjects[6].sendData = false;
/*
    // 1-0:21.7.0(00.378*kW)
    // 1-0:21.7.0 = Instantaan vermogen Elektriciteit levering L1
    telegramObjects[7].name = "power_l1";
    telegramObjects[7].attributeID = 0x4004;
    strcpy(telegramObjects[7].code, "1-0:21.7.0");
    telegramObjects[7].endChar = '*';
    telegramObjects[7].sendThreshold = (long) 3;

    // 1-0:41.7.0(00.378*kW)
    // 1-0:41.7.0 = Instantaan vermogen Elektriciteit levering L2
    telegramObjects[8].name = "power_l2";
    telegramObjects[8].attributeID = 0x4004;
    strcpy(telegramObjects[8].code, "1-0:41.7.0");
    telegramObjects[8].endChar = '*';
    telegramObjects[8].sendThreshold = (long) 3;

    // 1-0:61.7.0(00.378*kW)
    // 1-0:61.7.0 = Instantaan vermogen Elektriciteit levering L3
    telegramObjects[9].name = "power_l3";
    telegramObjects[9].attributeID = 0x4004;
    strcpy(telegramObjects[9].code, "1-0:61.7.0");
    telegramObjects[9].endChar = '*';
    telegramObjects[9].sendThreshold = (long) 3;
*/

#ifdef DEBUG
    //Serial.println("Data initialized:");
    ESP_LOGI(TAG, "Data initialized:");
    for (int i = 0; i < NUMBER_OF_READOUTS; i++)
    {
        ESP_LOGI(TAG, "%s", telegramObjects[i].name);
       // Serial.println(telegramObjects[i].name);
    }
#endif
}


long getValue(char *buffer, int maxlen, char startchar, char endchar)
{
    int s = findCharInArrayRev(buffer, startchar, maxlen - 2);
    int l = findCharInArrayRev(buffer, endchar, maxlen) - s - 1;

    // Verify data - if message is corrupted, then there is high chance of missing start of end char which would lead to reboot of ESP
    if(s <= 0 || l <= 0) {
#ifdef DEBUG
            //Serial.println((String) "Wrong input data. s: " + s + " l: " + l);
            ESP_LOGW(TAG, "Wrong input data. s: %d l: %d", s, l);
#endif
        return 0;
    }

    char res[16];
    memset(res, 0, sizeof(res));

    if (strncpy(res, buffer + s + 1, l))
    {
        if (endchar == '*')
        {
            if (isNumber(res, l))
                return (1000 * atof(res));
        }
        else if (endchar == ')')
        {
            if (isNumber(res, l))
                return atof(res);
        }
    }

    return 0;
}

/**
 *  Decodes the telegram PER line. Not the complete message. 
 */
bool decodeTelegram(int len)
{
    int startChar = findCharInArrayRev(telegram, '/', len);
    int endChar = findCharInArrayRev(telegram, '!', len);
    bool validCRCFound = false;

#ifdef DEBUG
    for (int cnt = 0; cnt < len; cnt++)
    {
        printf("%c", telegram[cnt]);
        //ESP_LOGI(TAG, "%c", telegram[cnt]);
        //Serial.print(telegram[cnt]);
        
    }
    ESP_LOGI(TAG, "\n");
    //Serial.print("\n");
#endif

    if (startChar >= 0)
    {
        // * Start found. Reset CRC calculation
        ESP_LOGI(TAG, "CRC Restart!");
        currentCRC = crc16(0x0000, (unsigned char *)telegram + startChar, len - startChar);
    }
    else if (endChar >= 0)
    {
        // * Add to crc calc
        currentCRC = crc16(currentCRC, (unsigned char *)telegram + endChar, 1);

        char messageCRC[5];
        strncpy(messageCRC, telegram + endChar + 1, 4);

        messageCRC[4] = 0; // * Thanks to HarmOtten (issue 5)
        validCRCFound = (strtol(messageCRC, NULL, 16) == currentCRC);

#ifdef DEBUG
        if (validCRCFound)
            ESP_LOGI(TAG, "CRC Valid!");
            //Serial.println(F("CRC Valid!"));
        else
            ESP_LOGW(TAG, "CRC Invalid! %d message %ld", currentCRC, strtol(messageCRC, NULL, 16));
            //Serial.println(F("CRC Invalid!"));
#endif
        currentCRC = 0;
    }
    else
    {
        currentCRC = crc16(currentCRC, (unsigned char *)telegram, len);
    }
    
    ESP_LOGW(TAG, "Current CRC %d", currentCRC);

    // Loops throug all the telegramObjects to find the code in the telegram line
    // If it finds the code the value will be stored in the object so it can later be send to the mqtt broker
    for (int i = 0; i < NUMBER_OF_READOUTS; i++)
    {
        if (strncmp(telegram, telegramObjects[i].code, strlen(telegramObjects[i].code)) == 0)
        {
            // Handle empty objects
            if(strlen(telegramObjects[i].code ) < 3) 
            { 
                continue; 
            };
#ifdef DEBUG
            ESP_LOGI(TAG, "Got value: %s", telegram);
            //Serial.println("Get value " + String(telegram));
#endif
            long newValue = getValue(telegram, len, telegramObjects[i].startChar, telegramObjects[i].endChar);
            if (newValue != telegramObjects[i].value)
            {
                // Do not send values if they change by some really minor value
                if(abs(telegramObjects[i].value - newValue) > telegramObjects[i].sendThreshold) {

                    telegramObjects[i].sendData = true;
                }else{  
#ifdef DEBUG
                    ESP_LOGI(TAG, "Value of: %s with value: %ld old %ld was rejected due to threshold", telegramObjects[i].name, newValue, telegramObjects[i].value);
                    //Serial.println((String) "Value of: " + telegramObjects[i].name + " with value: " + newValue + " old " + telegramObjects[i].value + " was rejected due to threshold");
#endif
                }
                telegramObjects[i].value = newValue;
            }
#ifdef DEBUG
            ESP_LOGI(TAG, "Found a Telegram object: %s with value: %ld", telegramObjects[i].name, telegramObjects[i].value);
            //Serial.println((String) "Found a Telegram object: " + telegramObjects[i].name + " value: " + telegramObjects[i].value);
#endif
            break;
        }
    }

    return validCRCFound;
}
/*
bool readP1Serial()
{
    if (Serial.available())
    {
#ifdef DEBUG
        Serial.println("Serial is available");
        Serial.println("Memset telegram");
#endif
        memset(telegram, 0, sizeof(telegram));
        while (Serial.available())
        {
            // Reads the telegram untill it finds a return character
            // That is after each line in the telegram
            int len = Serial.readBytesUntil('\n', telegram, P1_MAXLINELENGTH);

            telegram[len] = '\n';
            telegram[len + 1] = 0;

            bool result = decodeTelegram(len + 1);
            // When the CRC is check which is also the end of the telegram
            // if valid decode return true
            //result = true;
            if (result)
            {
                return true;
            }
        }
    }
    return false;
}*/


void app_main(void)
{
    //zero-initialize the config structure.
    gpio_config_t io_conf = {};
    //disable interrupt
    io_conf.intr_type = GPIO_INTR_DISABLE;
    //set as output mode
    io_conf.mode = GPIO_MODE_OUTPUT;
    //bit mask of the pins that you want to set,e.g.GPIO18/19
    io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL;
    //disable pull-down mode
    io_conf.pull_down_en = 0;
    //disable pull-up mode
    io_conf.pull_up_en = 0;
    //configure GPIO with the given settings
    gpio_config(&io_conf);

    gpio_set_direction(3, GPIO_MODE_OUTPUT);    // RF switch power on
    gpio_set_level(3, 0);
    gpio_set_direction(14, GPIO_MODE_OUTPUT);   // select external antenna
    gpio_set_level(14, 1);

    configure_led();
    gpio_set_direction(GPIO_OUTPUT_IO_0, GPIO_MODE_OUTPUT);
    gpio_set_level(GPIO_OUTPUT_IO_0, 0);

    esp_zb_platform_config_t config = {
        .radio_config = ESP_ZB_DEFAULT_RADIO_CONFIG(),
        .host_config = ESP_ZB_DEFAULT_HOST_CONFIG(),
    };
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_zb_platform_config(&config));
    light_driver_init(LIGHT_DEFAULT_OFF);
    xTaskCreate(esp_zb_task, "Zigbee_main", 4096, NULL, 5, NULL);

        // Configure UART parameters
    const uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };

    setupDataReadout();
    static const char *telegram_test = "/ISK5\\2M550E-1013\r\n\0";
    int startChar = findCharInArrayRev(telegram_test, '/', 19);
    int crc_test = crc16(0x0000, (unsigned char *)telegram_test + startChar, 19 - startChar);
    printf("CRC first: %d %d\n", crc_test, startChar);

    // Install UART driver
    uart_driver_install(UART_NUM, P1_MAXLINELENGTH * 2, 0, 0, NULL, 0);
    uart_param_config(UART_NUM, &uart_config);
    uart_set_pin(UART_NUM, UART_TX_PIN, UART_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);

    while (1) {
        // Read data from UART
        memset(telegram_full, 0, sizeof(telegram_full));
        int len = uart_read_bytes(UART_NUM, telegram_full, P1_MAXLINELENGTH, 20 / 1000);
        if (len > 0) {
            // Null-terminate the data and print
            //telegram[len] = '\0';
                // Initialize a copy of the telegram to tokenize
            char *telegram_copy = strdup((char *)telegram_full);
            if (telegram_copy == NULL) {
                printf("Failed to allocate memory.\n");
                return;
            }
            uint16_t crc_code = crc16_full(telegram_full, len - 4);
            printf("Parsing: %s crc %d\n", telegram_full, crc_code);
            
            // Tokenize the telegram by line
            char *line = strtok(telegram_copy, "\n");
            while (line != NULL) {
                ESP_LOGI(TAG, "Line: %s\n", line);
                
                if(strcmp(line, " ") == 0) {
                    line = "";
                    //printf("Line null: %s\n", line);
                }
                // Process each line here as needed
                memset(telegram, 0, sizeof(telegram));
                //strcpy(line, telegram);
                int line_len = strlen(line);
                strncpy(telegram, line, line_len);
                //int line_len = strlen(line) + 1;

                telegram[line_len] = '\r\n';
                telegram[line_len + 1] = '\0';
                //telegram[P1_MAXLINELENGTH - 1] = '\0';  // Ensure null termination
                //printf("Copied token: %s\n", telegram);
                bool result = decodeTelegram(line_len + 1);
                ESP_LOGI("UART", "Length %d telegram: %s result: %d", line_len, telegram, strlen(telegram));

                // Get the next line
                line = strtok(NULL, "\n");
            }

            // Free the allocated memory
            free(telegram_copy);

            //telegram[len] = '\n';
            //telegram[len + 1] = 0;


            
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
        //ESP_LOGI(TAG, "CRC Valid!");
    }
}
